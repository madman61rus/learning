                          Базовые типы

Числа

    Операции над числами
    +   плюс
    -   минус
    *   умножение
    /   деление с плавающей точкой
    //  целочисленное деление
    %   остаток от деления  ( divmod() - возвращает кортеж, частное и остаток)
    **  возведение в степень

    0b 0B двоичная
    0o 0O восьмеричная
    0x 0X шестнадцатиричная

Целый тип (int)

    Начиная с 3, тип long отсутствует, а int может быть любого размера, даже
    больше 64 бит

Числа с плавающей точкой (float)

    float("inf") выдает самое большое число float, которое можно использовать
    в сравнениях для нахождения максимума или минимума


    Преобразование типов

        int(True)   - 1
        int(False)  - 0

        int(89.34)  - 89
        int(1.0e4)  - 1000

        int('99')   - 99
        int('-23')  - 23

        float(True) - 1.0
        float(False)- 0.0

        float(98)   - 98.0
        float('99') - 99.0


Строки

    Строки являются неизменяемыми.

        'Snap'
        "Crackle"
        ''' Многострочная
          строка '''

    Конкатенация происходит с помощью +

        "Hello" + 'world'  - "Hello world"

    Оператор * размножает строку нужное количество раз

        'H' * 6  - 'HHHHHH'

    Извлечь нужный символ из строки можно с помощью []

        a = 'Hello'
        a[0]          - H
        a[-1]         - o

    Извлечь подстроку из строки можно с помощью

        [start:end:step]  - от start до end, с шагом step
        [:]               - все, от начала, до конца
        [start:]          - от start до конца
        [:end]            - от начала до end-1
        [start:end]       - от start до end-1

        если шаг отрицательный, то движение будет от конца к началу

        Для вычисления длины строки есть функция len

          len("empty")

        Для разбиения строки на список, по разделителю, можно использовать функцию
        split()

          "hello, my, friend".split(",") -> ["hello","my","friend"]

        Для объединения элементов списка в строку, используется функция
        join

          "разделитель".join(список)

          ",".join(['one','two','three']) -> "one,two,three"

        Некоторые функции для работы со строками

          len(строка) - кол-во символов в строке
          строка.startswith(образец) - начинается ли строка с образца ?
          строка.endswith(образец) - заканчивается ли строка образцом ?
          строка.find(образец) - поиск первого вхождения образца в строке
          строка.rfind(образец) - поиск последнего вхождения образца
          строка.count(образец) - сколько раз встречается образец в строке
          строка.isalnum() - являются ли все символы строки цифрами ?
          строка.strip('.') - удаление . с обоих концов
          строка.capitalize() - Первое слово с большой буквы
          строка.title() - Все слова с большой буквы
          строка.upper() - Все символы в верхний регистр
          строка.lower() - Все символы в нижний регистр
          строка.swapcase() - Сменить регистр букв
          строка.center(30) - Отцентрировать строку на 30 пробелов
          строка.ljust(30) - Сдвинуть строку на 30 символов влево
          строка.rjust(30) - Сдвинуть строку на 30 символов вправо
          строка.replace('duck','marmoset') - Заменяем подстроку duck в строке на marmoset
          строка.replace('duck','marmoset',100) - тоже, но только 100 раз





    Преобразование к строке

        str(96.5)  - '96.5'
        str(1.0e4) - '10000.0'



Списки

  Упорядоченный набор элементов разного типа. Обозначается []

    Пустой список можно объявить как :

      empty_list = []

      или

      empty_list = list()

    Не пустой список :

      elements = [10, 'a' , "bbb" , [1,2,3] , 5]

    Преобразовать что-то в спискок :

      list('cat') -> ['c','a','t']

  Изменение элемента списка происходит по его индексу

  Добавление элементов :

      Добавление в конец списка:

          elements.append(23)

      Вставка по индексу. Элементы справа сдвигаются на одну позицию :

          elements.insert(0,'bbb')

  Длина списка:

      Узнать длину списка можно с помощью функции len():

          len(elements)

  Удаление элементов :

      Удаление по индексу:

          del elements[0]

      Удаление последнего элемента методом pop, что позволяет работать
      с удаляемым значением:

          elem = elements.pop()

      Удаление элемента из определенной позиции

          elem = elements.pop(1)

      Удаление элементов по значению. Удаляется только первое найденное вхождение:

          elements.remove('bbb')

  Получение элементов списка:

      elements[0] - по смещению
      



  Упорядочивание списков :

      Метод sort() упорядочивает по алфавиту !!! изменяя список:

          elements.sort()

      В обратном порядке:

          elements.sort(reverse=True)

      Метод sorted() упорядочивает по алфавиту, но не изменяя список:

          sorted_elements = sorted(elements)

      Метод reverse() разворачивает список !!! изменяя список:

          elements.reverse()




Словари
Кортежи
Файлы
Множества
Прочие базовые типы
Типы структурных элементов программ

                                Циклы

Цикл for

  Цикл перебора в множестве:

      elements = [1,2,3,4,5,6,7,8,9]
      for elem in elements:
          print(elem)

Цикл while:

      while условие:
        ......

Удаление всех вхождений в список через while:

      pets = ['dog','cat','dog','horse','elephant','cat']

      while 'cat' in pets:
          pets.remove('cat')


Прерываение выполнения происходит через break

Переход на следующую итерацию - continue


                                        Списки

Создание списка

  Функция range(начало,смещение,шаг) создает числовую последовательность:

      range(1,5) #создает последовательность 1,2,3,4


Создание числового списка

  Чтобы создать числовой список с помощью range(), можно воспользоваться функцией list()

      list(range(1,5)) # [1,2,3,4]

Генератор списка

      squares = [value**2 for value in range(1,11)]


Срезы

  Чтобы создать срез списка, необходимо задать индексы первого и последнего элемента

      elements[0:3]

Копирование списка

  Скопировать список можно с помощью среза

      new_elements = elements[:]

  Если применить просто равенство, то создастся ссылка на старый список

  Проверить входит ли значение в список можно с помощью выражения in :

      'mushrooms' in request

Проверить отсутствие значения в списке можно с помощью выражения not in :

      'mushrooms' not in request


                                              Кортежи

Кортеж - неизменяемый список элементов.

    Определение кортежа:

        dimensions = (200,30)
        dimensions[0]         # 200

    Перебор значений в кортеже:

        for dimension in dementions:
            print(dimension)

Значение в кортеже изменить нельзя, но можно присвоить переменной другой кортеж:

        dimensions = (200,30)
        dimentions = (150,20)

Одноэлементный кортеж

        (2, )
        a = (2,3,4)
        (2, ) + a   -> (2,2,3,4)


                                Операторы выбора

Оператор if:

    if условие:
      .....
    else:
      .....

или

     if условие:
       ......
     elif условие:
       ......
     else:
       ......



                                Словари

Словари - это множества, состоящие из пары ключ-значение

    alien = {'color':'green', 'points': 10}

Получить значение можно по ключу

    alien['color']  # green

Добавить пару можно :

    alien['screem'] = 'eeeeeeeep'

Создание пустого словаря

    alien = {}

Изменение значения :

    alien['color'] = 'red'

Удаление пары :

    del alien['color']

Перебор словаря

    Перебор пар ключ-значение:

        for key,value in user.items():
          ......

    Перебор всех ключей:

        for key in user.keys():
          .....

        Так как по умолчанию словарь выдает список ключей, то это же
        можно написать как :

        for key in user:
          .....

    Для получения упорядоченного списка ключей можно использовать sorted():

        for name in sorted(languages.keys()):
          ......

   Перебор всех значений в словаре :

        for name in names.values():
          ......

   Перебор всех значений без повторений :

        for name in set(names.values()):
          ......


                                      Ввод

Ввод от пользователя можно получиться с помощью функции input(подсказка)

        message = input("Tell me your name")


                              Распаковка и Присваивание

Распаковать и присвоить списочный тип можно так :

      seen = set()
      (acc, seen) = ([], set())
      x, y, z = [1,2,3]
      x, y, z = {1,2,3}     #set is unordered
      x, y, z = "xyz"
      rectangle = (0,0), (4,4)
      (x1, y1), (x2, y2) = rectangle

В версии 3.0 появилась дополнительная версия распаковки:

      first, *rest = range(1,5)  # first=1,rest = [2,3,4]
      first, *rest, last = range(1,5) # first=1,rest=[2,3],last=4
      даже
      *_, (first, *rest) = [range(1,5)] * 5    # first=1

                                      Функции

Определение функции:

      def название_функции(параметр_a, параметр_b):
          .....

      Параметры функции могут быть позиционнными

        def function('ass',10):

      или именованными

        def function(a='ass',b=10):

      Если функция имеет фиксированную арность, то именованные аргументы можно
      передавать без имени:
          def flatten(xs, depth=None):
            pass

          flatten([1,[2],3],1)


      Значения по умолчанию :

        def function(name,age=18):

      Запрет изменения списка как параметра, путем копирования списка

        def function(names[:]):

      Передача произвольного набора параметров. В toppings будет кортеж с
      параметрами (упаковка аргументов)

        def function(*toppings):

      При этом распаковка аргументов при этом они подставляются в функцию
      симметрично:

        function(*(1,2,3,4)
        function(*[3,22,3,34])

      Если используются позиционные параметры и набор произвольных аргументов,
      то произвольные аргументы должны стоять в конце

        def function(name,*toppings)

      Так же в функцию может передоваться неизвестное количество пар ключ-значение
      , которые упакованы в словарь

        def function(name,lastname,**user_info)
        function('albert','Woo',
              location='princeton',
              field='physics'
                )


Если в функцию передать изменяемое значение и проделать с ним какие-то действия
, то значение изменится ( передается по ссылке). Чтобы, например передать в
функцию set и не изменять его, можно сделать :

        def unique(iterable, seen=None):
          seen = set(seen or [])          # копируется значение seen или []
          ......

                                      Модули

Модуль, это отдельный файл с расширением py , в котором хранятся функции.
Импорт из модуля выглядит так :

      import модуль
      модуль.имя_функции()

  Импортирование конкретных функций из модуля

      from имя_модуля import имя_функции

  Можно импортировать несколько функций

      from имя_модуля import функция0, функция1, функция2

  Если импортировать конкретные функции, то указывать имя модуля перед
  вызовом функции не обязательно

  Назначение псевдонима для импортированной функции

      from pizza import make_pizza as mp

      from имя_модуля import функция as псевдоним

  Назначения псевдонима для модуля

      import имя_модуля as псевдоним

  Импортирование всх функций модуля

      from имя_модуля import *


                        Функциональное программирование

Лямбды

    lambda arguments: expression

    эквивалент

    def <lambda> (arguments):
      return expression
Map

    Применяет функцию к каждому элементу последовательности

    list(map(identity, range(4))) #Чтобы увидеть результат, надо привести к list
                                  #или set или dict

    Пример использования:

    set(map(lambda x: x % 7, [1,2,5,3,4]))

    Применяет к последовательнастям, количество эелементов в результате определяется
    длиной наименьшей из последовательностей

    list(map(lambda x,n: x ** n, [2,3], range(1,8))) -> [2,9]

Filter

    Убирает из последовательности элементы, не удовлетворяющие предикату

      list(filter(lambda x: x % 2 != 0, range(10))) # [1,3,5,7,9]

    Вместо предиката можно передать None, и останутся только truthy значения

      list(filter(None, [0,None,{},set(),42])) #-> [42]

Zip

    Сшивает вместе элементы нескольких последовательностей

      list(zip("abc",range(3), [42,43,42]))) #[('a',0,42),(b,1,43),(c,2,42)]

    Как и в map, длина должна урезаться до самой короткой последовательнсоти


Генераторы списков

    [x ** 2 for x in range(10) if x % 2 == 1] #[1,9,25,49,81]

Генераторы сета

    { x % 7 for x in [1,9,16,-1,2,5]} # {1,2,5,6}

Генераторы словарей

    {x: x ** 2 for x in range(4)} # {0: 0, 1: 2, 2: 4}


                              Классы

Класс создается с помощью ключевого слова class . Имя класса должно начинаться
с большой буквы

    class Dog():
      ....

    В Python 2.7

    class Dog(object):

Конструктор класса:

    def __init__(self,параметр,параметр):
      .....

Создание экземпляра класса:

    my_dog = Dog('willy',10)

Изменение значений атрибутов:

    Напрямую:

      my_car.odometr = 200

    С помощью метода:

      my_car.update_odometr(200)


Наследование

     наследуемся от класса Car и инициализируем его с помощью вызова
     родительского конструктора. Класс может наследоваться от множества класов

     class ElectricCar(Car):
        def __init__(self,make,model):
          super().__init__(make,model)

    В 2.7 функция super() должна получать два аргумента: ссылку на класс-потомок
    и объект self. А сам родитель должен быть объявлен с параметром object

Переопределение методов родительского класса

    Для переопределения метода суперкласса, в потомке необходимо определить
    метод с тем же именем что и у метода суперкласса

В качестве оттрибутов класса могут выступать другие классы ( композиция)

                              Модули

Каждый класс можно хранить в отдельном файле-модулею Ипортировать такой класс
можно с помощью

    from имя_модуля import имя_класса

В модуле можно хранить несколько классов.Чтобы импортировать несколько классов,
можно сделать :

    from имя_модуля import имя_класса,имя_класса2.....

Можно импортировать весь класс и обращаться к его членам через точку

    import car

Импортировать все классы из модуля можно с помощью

    from имя_модуля import *



                              Файлы

Вариант открытия файла с автоматическим закрытием:

    with open(имя_файла) as переменная_указатель:
      content = переменная_указатель.read()

    чтение по сторкам можно выполнить с помощью for:

      for line in переменная_указатель:
          ......

    сохранение содержимого в списке по строкам

      with open(filename) as file_object:
        lines = file_object.readlines()



Закрыть файл можно и в ручную с помощью close()
