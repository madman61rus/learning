209
Комментарии

	Однострочные

		//

	Многострочные

		/* */

	JavaDoc 

		/** */


Примитивные типы

	Целочисленные

		byte		- 1 байт
		short 	- 	  2 байта
		int 		- 4 байта
		long		- 8 байт

	С плавающей точкой

		float 	-	4 байта
		double	-	8 байт

	Символ

		char		- 2 байта

	Булев

		boolean - 1 байт

Целочискленные литералы :

		12343 - десятичные
		070232 - восьмеричные
		0xAF 0x345 - шестнадцатиричные
		0b10100 - двоичные ( начиная с java 7)

		1232334L - обозначение литерала long
		123_234__455 - разделение разрядов
		010101_10010_111000 - то же

Литералы с плавающей точкой

		2.02  10.2 - стандартная форма
		6.02Е32  31415е-15 - экспоненциальная

		0x12.2P2 - экспоненциальная в шестнадцатеричной системе

		23.23333F - обозначение float
		3.234565D - обозначение double

		234_344__435.023 - разделение разрядов

Логические

		true не равен 1
		false не равен 0

Символьные литералы

		'a' 'F' - литералы
		'\144'  - символ в 8-й форме (а)
		'\u0061' - символ в 16-й форме (а)

Строковые литералы

		"Hello"

		Управляющие символы и восьмеричная или шестнадцатеричная форма записи,
		определенные для символьных литералов, действуют точно так же и в строковых
		литералах.



Переменные

		тип идентификатор [=значение][, идентификатор [=значение]];

		int a,b,c ;
		int a=10, e, c= 10;
		char x = 'x';
		double d = a + b;


Преобразование и приведение типов

	Общее правило приведения типов:
		Сначало byte,short,char приводятся к int, затем все выражение продвигается к
		long, если один из операндов типа long, или к float, если один из операторов
		типа float, а если один из операндов double, то и все выражение будет double


	Автоматическое приведение:

			Два условия преобразования
				- оба типа совместимо
				- длина целевого типа больше исходного

			Во время математических операций над byte, short,char они автоматически
			преобразовываются в int

				Неправильно
						byte b = 50;
						b = b * 2;
				Правильно
						byte b = 50;
						b = (byte)(b * 2);


	Ручное приведение типов

			(целевой_тип) значение ;

			int a;
			byte b;
			b = (byte) a;

			Если приведение идет с усечением, то получится значение текущего типа -
			максимальное число в целевом типе (деление по модулю)


Массивы

			тип[]  имя_переменной = new тип [размер];
			тип имя_переменной[] = new тип [размер];

			Элементы массива будут автоматически инициализированны
			нулевыми значениями(для числовых типов), false для логических, и null для
			ссылочных

			Пример инициализации сразу при объявлении
			int monthDays = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 } ;

			Создание анаонимного массива 
			new int[] {1,2,3,4,5,6,7}

			Копирование массивов
				int[] newArray = Arrays.copyOf(старый_массив,длина_нового_массива);
			Если длинна нового массива больше, то эти элементы заполняются 0 или false


			Отсортировать массив можно с помощью метода sort класса Arrays
				int[] a = new int[100];
				Arrays.sort(a);





Многомерные массивы

			int twoD [] [] = new int [4] [5] ;
			int[] [] twoD  = new int [4] [5] ;

			Резервировать память под многомерный массив можно и так :

				int twoD [] [] = new int [4] [] ;
				int twoD[0] = new int[5];
				int twoD[1] = new int[3];
				int twoD[2] = new int[4];
				int twoD[3] = new int[7];


																					Операции


Арифметические

		+
		-
		*
		/
		%
		++
		+=
		-=
		*=
		/=
		%=
		--

Поразрядные операции

		~ 	Поразрядная унарная операция НЕ
		&		Поразрядная унарная операция И
		|		Поразрядная унарная операция ИЛИ
		^		Поразрядная унарная операция Исключающее ИЛИ
		>>  Сдвиг вправо
		>>> Сдвиг вправо с заполнением нулями
		<<	Сдвиг влево
		&=	Поразрядовая И с присваиванием
		|=	Поразрядовая ИЛИ с присваиванием
		^=	Поразрядовая Исключающая ИЛИ с присваиванием
		>>= Сдвиг вправо с присваиванием
		>>>= Сдвиг вправо с заполнение нулями и присваиванием
		<<=  Сдвиг влево с присваиванием

Операции отношения

		==
		!=
		>
		<
		>=
		<=

Логические операции

		& 		Логическое И
		|			Логическое ИЛИ
		^			Логический XOR
		||		Короткое ИЛИ
		&&		Короткое И
		!			НЕ
		&=
		|=
		^=
		==
		!=
		?:		Тернарная

Операция присваивания

		Возвращает результат присваивания, поэтому работает
			a = b = c = 100 ;

Тернарный оператор

		выражение1 ? выражение2 : выражение3 ;




											Ввод/Вывод

Чтобы прочитать данные с консоли, можно использовать класс Scanner

		Scanner scanner = new Scanner(System.in);
		scanner.nextLine() 	// читает строку
		scanner.next()      // читает слово отделенное пробелами
		scanner.nextInt()	// читает целое
		scanner.next.Double() // читает Double


Для чтения с консоли паролей можно использовать класс Console

		Console cons = System.console();
		String username = cons.readLine("User name:");
		char[] passwd = cons.readPassword("Password: ");


Для вывода данных, можно использовать форматированный вывод :

		System.out.printf("%,.2f", 10000.0 / 3.0);



											Чтение из файла

Из файла можно так же читать через объект Scanner. Но если файл не найден, то будет выброшено исключение

		Scanner in = new Scanner(Paths.get(путь_к_файлу), кодировка);


Для записи можно использовать 

		PrinterWriter out = new PrintWriter("myfile.txt","UTF-8");





											Управляющие операторы


if

		if (условие) {
			....
		}else{
			....
		}

	if-else-if

		if (условие){
			....
		}else if(условие2){
			....
		}else{
			....
		}


Оператор switch

		switch (выражение) {
			case значение1:
					.....
					break;
			case значение2:
					.....
					break;
			.....
			default:
					.....
		}

		До 7-ки выражение могло быть только byte,short,int,char или перечеслимый тип
		С 7-ки добавился String
		break можно пропускать, чтобы создать проваливание на следующее значение


																		Циклы

while

		while(условие){
			.....
		}

do-while

		do{
			......
		}while(условие);

for

		for (инициализация; условие; итерация) {
				.....
		}

		В инициализации и итерации можно использовать несколько операторов, разделен
		ных запятыми
				int b;
				for (int i= 0, b=10; i < 10; i++){
					.....
				}

Разновидности for

		Будет выполняться пока done не false равно:
			for (; done;){
				.....
			}

		Бесконечный цикл:
			for(;;){
				....
			}

		Стиль foreach
			for(тип переменная _итерации : коллекция) блок_операторов

			переменная_итерации доступна только для чтения.


																		Операторы перехода

break

		- Выход из цикла
		- Выход в switch
		- Переход в стиле goto
				....
				first:{
					second:{
						third:{
							if(t == 0) break second;
						}
					}
					System.out.println("second"); // выполнится
				}

			такой стиль можно использовать и с циклами:
				outer: for (int i=0;i<100; i++){
					.....
					if (i==2) break outer;
				}


continue

		- переход к следующей итерации
		- может так же переходить на метку следующей итерации

				outer: for(......){
					for (.....){
							if(i==0) continue outer;
					}
				}

return

		передает управление объекту, который вызвал данный метод



																			Классы


Отношения между классами

	Зависимость (Использует - что-то)
		Один класс зависит от другого класса, если его методы выполняют какие-нибудь
		действия над экземплярами этого класса. Обозначается прерывистой стрелкой

	Агрегирование (Содержит что-то)
		Агрегирование означает, что объект класса А содержит объекты класса B.
		Обозначается незакрашенным ромбом

	Наследование (является чем-то)
		Наследование выражает отношения между конкретным и более общим классом
		Обозначается незакрашенным треугольником



Упрощенная схема определения класса

		class имя_класса{
			тип переменная_экземпляра1;
			тип переменная_экземпляра2;
			...
			тип переменная_экземпляраN;

			тип имя_метода1(список_параметров){
				....
			}

			тип имя_методаN(список_параметров){
				....
			}
		}


Объявление переменной и выделение памяти для экземпляра объекта

		класс переменная_класса = new имя_класса();

		имя_класса обозначает конструктор класса. если конструктор не изменен,то
		вызывается конструктор по-умолчанию

Присваивание переменным ссылок на объекты

		Box b1 = new Box();
		Box b2 = b1; // !!! b2 - это ссылка на тот же объект b1 !!!

		b1 = null; // !!! b2 до сих пор ссылается на объект


Методы

		[модификатор_доступа] тип|void имя([список_параметров]){
			....
			[return значение;]
		}

Модивикаторы для методов:

		static

				Статический метод. Не может использовать нестатичесие элементы. Может
				вызываться без создания экземпляра.

		abstract

				Этот метод не содержит реализации

		final

				Этот метод не может быть переопределен в наследниках

		strictfp

				Говорит компилятору использовать особую точность в вычислениях

		native

				Говорит что этот метод реализован на языке С (или С++ ?)

		synchronized

				Метод будет выполнятся за один раз только одним потоком.


Передача параметров

		Примитивные типы передаются по значению, ссылочные по ссылке


Перезагрузка методов

		При перезагрузке имя методов совпадает, а количество параметров может
		отличаться. Метод выбирается по типу и количеству аргументов. Если при вызове
		конструктора, тип не совпадает, то тип аргумента может быть расширен до нужного
		(например int -> double). Это происходит когда не найдено точное соответствие.

Конструктор

		Конструктор имеет вид:

			[модификатор_доступа] имя_класса([параметры]){
				...
			}

			конструктор не имеет возвращаемого значения, так как по умолчанию
			возвращает объект инициализированного класса

Перезагрузка конструктора

		Конструктор можно перезагружать  так же как и обычные методы.

Инициализировать поля класса до конструктора можно в блоке инициализации

		{
			......
		}

Метод finalize()

		Выполняется при уничтожении объекта. Но сей час не известен )))

		protected void finalize(){
			.....
		}


Управление доступом

		По-умолчанию, член класса доступен только в своем пакете
		public - член доступен из любого кода
		private - доступен только членам того же класса
		default - доступен только в этом пакете
		protected - виден в наследниках ( которые в этом же пакете ? )


Ключевое слово static

		Член класса, объявленный как static, доступен без создания самого класса

		Методы объявленные как static могут только :
			- вызывать только статические методы
			- им доступны только статические свойства класса
			- не могут содержать ссылок на this илм super

		Для инициализации статических свойств, можно объявить статический блок,
		который выполняется при первой загрузке класса

			static {
				....
			}


Ключевое слово final

			Делает свойство класса фактически константой. Свойство может быть
			инициализировано или сразу (или в статическом блоке) . Имена таких свойств
			обычно пишутся прописными буквами.

Ключевое слово transient

			Показывает что данное свойство не будет участвовать в сериализации

Ключевое слово volatile

			Делает свойство потокобезопасным. Поток не будет использовать кешированную
			версию, а будет читать напрямую.



Вложенные и внутренние классы

		Область действия вложенного класса ограничена областью действия внешнего.
		Вложенный класс имеет доступ ко всем членам(и закрытым) внешнего класса, но
		внешний не имеет доступа к членам внутреннего класса.



																		Наследование


Наследование одним классом другого обозначается ключевым словом extends.

	class имя_подкласса	extends	имя_суперкласса

	Класс может наследоваться только од одного суперкласса.
	Переменная типа супер класса может ссылаться на объект подкласса. Но через
	эту переменную будут доступны только те члены, которые есть у суперкласса.


Ключевое слово super

	К членам супер класса из подкласса можно обратиться через ключевое слово
	super.

Вызов конструктора суперкласса :

			super (список_аргументов);

			Вызов метода super() должен быть самым первым оператором в
			конструкторе подкласса.

			Если в подклассе не вызывает явно конструктор суперкласса, то будет вызван
			конструктор суперкласса без аргументов.

Доступ к членам суперкласса

			super.член

			член может быть методом или перемнной суперкласса, сокрытые в классе-потомке


Порядок вызова конструкторов

		Конструкторы вызываются в порядке наследования, начиная с самого верхнего класса


Переопределение методов

		Если в наследнике есть такой же метод как и в суперклассе, с такой же сигнатурой
		, то метод наследника переопределяет родительский метод.
		Если имена методов одинаковы, а сигнатуры отличаются, то метод называется
		перезанруженным, а не переопределенным.


Абстрактные методы

			Для того, чтобы некоторые методы переопределялись в подклассе, их
			необходимо объявить с модификатором типа abstract

				abstract тип имя( список_параметров );

			Любой клас, который имеет один или более абстрактных методов, должен
			быть объявлен как абстрактный. Для этого необходимо поставить ключевое
			слово abstract перед объявлением класса

				abstract class ......

			У абстрактного класса не может быть объектов. Он не может быть получен с
			помощью new. Любой подкласс, производный от абстракного класса, должен
			реализовать все абстрактные методы из своего суперкласса или же сам быть
			объявлен как абстрактный. Но можно создавать переменную типа абстракного
			класса. А потом присваивать ей ссылку на его наследников.


final и наследование

			- Предотвращение переопределения метода.
					...
					final void meth(){
						...
					}

			- Предотвращение наследования
					....
					final class A {
						....
					}



																	Пакеты

Чтобы указать в каком пакете находится класс, необходимо в начале файла класса
указать

		package пакет;

если пакет не указан, то используется пакет по умолчанию. Допускается так же
 формировать иерархию пакетов

 		package пакет1[.пакет2[.пакет3]];

Физически, пакеты это расположение в файловой системе. Пакет - это каталог

Поиск пакетов начинается с в текущем рабочем каталоге. Если там пакет не найден,
то поиск продолжается в подкаталогах текущего каталога.Так же можно установить
переменную CLASSPATH. Так же переменную classpath можно указать и в командной
строке: -classpath

Импорт пакетов:

		import пакет1 [.пакет2].(имя_класса | *)

Статический импорт позволяет импортировать только статические методы и поля

		import static java.lang.System.*;

		.....
		exit(0); // вместо System.exit 

или

		import static java.lang.System.out;



															Расположение классов

Указать путь к классам можно с помощью ключа -classpath

		java -classpath /home/user/classdir:.:/home/user/archives

Можно указать переменную окружения CLASSPATH

		




																Интерфейсы

Интерфейсы аналогичны классам, но не содержат переменные экземпляра, а объявления
их методов, как правило, не содержат теоло метода. Один класс может реализовать
любое количество интерфейсов.

Чтобы реализовать интерфейс, в классе должен быть реализован полный набор методов,
определенных в этом интерфейсе.

Когда интерфейс реализуется в классе, все переменные, объявленные в интерфейсе,
оказываются в области видимости класса. Соответственно, в интерфейсе можно объявить
только переменные и имплементировать его в несколко классов, что создаст глобальные
константы.

Интерфейс должен быть объявлен с модификатором доступа public или по умолчанию.

		модификатор_доступа interface имя{
			возвращаемый_тип имя_метода1 (список_параметров);
			возвращаемый_тип имя_метода2 (список_параметров);

			тип имя_завершенной_переменной1 = значение;
			тип имя_завершенной_переменной2 = значение;
			....
			тип имя_завершенной_переменнойN = значение;
		}

С версии 8, в интерфейсе можно написать реализацию метода по умолчанию. Этот метод
необходимо пометить ключевым словом default

			public interface Bla {
			......
				default String go(){
					return "Statring..";
				}
			}

Чтобы класс мог реализовать интерфейс, в его объявление необходимо включить
ключевое слово implements, а затем создать методы, определенные в интерфейсе.

		мод_лоступа class имя_класса [extends суперкласс] [implements интерфейс]
										[, интерфейс]{
										....
										}

К реализациям интерфейсов, можно получить доступ через ссылки на сами интерфейсы

		Callback c = new Client();

Интерфейс может быть объявлен членом класса или другого интерфейса, тогда он
может быть объявлен как public, prived, protected. И называется такой интерфейс
- вложенным.

Когда вложенный интерфейс используется за пределами своей вложенности, то
его имя должно быть дополнительно уточнено именем класса или интерфейса в
котором он находится.

Интерфейсы могут наследоваться друг от друга с помощью ключевого слова extends


259
