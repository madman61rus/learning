                        Команды интерпретатора

User switch command
--> h
с [nn] - connect to job
i [nn] - interrupt job
к [nn] - kill job
j      - list all jobs
s [shell] - start local shell
r [node [shell] ] - start remote sh e ll
q  - quit erlang
? | h  - this message


                            Числа

Иcпользуется для обозначения целых и вещественных чисел. Основанием числа может
быть число из интервала от 2 до 36 ( в старых версиях до 16) - Основание#Число.
Нотация $char так же воспринимается как целое число:

43.
-->43
$A.
-->65
$\n.
-->10
2#101.
-->5
2.3.
-->2.3
2.3e3
-->2.3e3

Операции над числами такие же как и везде:
*
/
+
-
div - целочтсленное деление
rem - остаток от деления


                                Атомы

Атомы это литералы, константы, значением которых является их имя. Атомы начинаются
с маленькой буквы. Если атом содержит любые другие символы кроме букв, цифр,
знака _ или @ или начинается с большой буквы, то он должен быть заключен в
одинарные кавычки

atom.
-->atom
atoms_rule.
-->atoms_rule
'This is the atom'.
-->'This is the atom'

                              Переменные

В Erlang переменные начинаются с большой буквы. Они иммутабельны.

One = 1.
Two = 2.
Three = One + Two.



                              Булев тип

Булевы летералы это - false и true
Операции :

and  - и
or   - или
xor  - исключающее или
not  - не
andalso - короткое и
orelse  - короткое или

=:= - строгое равенство
=/= - строгое не равенство
==  - равенство
/=  - не равенство

<
>
>=
=<

Порядок элементов в сравнении :
числа < атомы < ссылочные_значения < функции < порты < индентификаторы_процессов
< кортежи < списки < двоичные_данные


                              Кортежи

Обозначается с помощью {}. Кортеж, который содержит атом и один дополнительный
элемент, называется кортеж с тегом {point, {X,Y}}

X = 10, Y = 5.
Point = X,Y.
-->{10,4}

Извлечение из кортежа :
  {Z , M} = Point.
  Z.
  ->10
  M.
  ->4


                              Списки

Может содержать разные элементы. Записывается как [one,10,23,Two]
++ используется для склейки двух списков, -- для вычитания. Эти операции право
ассоциативные, т.е выполняются справа на лево.

[1,2,3] - [1,2] - [3].
-> [3]

[1,2,3] - [1,2] - [2].
-> [2,3]

Для получения головы списка можно использовать BIF функцию hd([1,2,3,4]), а
хвост tl([1,2,3,4]) или использовать сопоставление с образцом типа [Head|Tail]

List = [2,3,4].
NewList = [1|List].
-> [1,2,3,4]


[Head|Tail] = NewList.
Head.
-> 1
Tail.
-> [2,3,4]


                                Генераторы списков

Создаем список {2n : n C L}, где L список [1,2,3,4].

  [ 2*N || N <- [1,2,3,4]].
  [2,4,6,8]

В генератор можно добавить ограниичение через запятую

  [X || X <- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0].
  [2,4,6,8,10]

Общий вид генератора
  NewList = [Выражение || Образец <- Список, Условие1, Условие2... УсловиеN ]

Часть Образец<-Список называется выражением-генератором.Их может быть несколько
  [X + Y || X <- [1,2,3], Y<-[2,3,4]].
  ->[2,4,5,4,5,6,5,6,7]

Выражение-генератор так же может играть роль фильтра, применяя сопоставление с
образцом
  Weather = [{toronto,rain},{monreal,storm},{london,fog},{paris,fog}].
  FoggyPlaces = [X || {X,fog} <- Weather].
  ->[london,paris].


50
