Функции помощи

	dir(S) - Получить список атрибутов объекта
	help(S.replace) - Справка по методу replace

Комментарии

	# - однострочный

Базовые типы

	Числа							123 , 3.14, 3+4j, Decimal, Fraction
	Строки							"Spam", 'Guido', b'x01c'
	Списки							[1,[2,'three'],14]
	Словари							{'food' : 'spam', 'number' : 10}
	Кортежи							(1,'spam', 4, 'U')
	Файлы							myfile=open('egg','r')
	Множества						set('abc'), {'a','b','v'}
	Прочие базовые Типы             Сами типы,лог. значения, None
	Типы структурных эл-тов			
	Типы реализации



Числа

	Обычные 123, -24, 0
	Вещественные 1.23 3.14е-10
	Восьмеричные 0177 (2-я) 0o177 (3-я)
	Шестнадцатеричные 0х9ff 0X9ff
	Двоичные  0b01010
	Комплексные 3+4j 3.0+4.0j, 3j

	Для того чтобы изменить представление чисел на другие системы счисления,
	можно использовать oct(), hex(), bin()

	Функция int() преобразует строку в целое число. Вторым аргументом можно указать
	систему счисления

	В 3 целые числа автоматически дают неограниченную точность(
	В 2 необходимо было использовать специальный тип и добавлять в конце L)

	Операции над числами

	+  - сложение
	-  - вычитание
	*  - уножение
	** - степень
	/  - деление ( в 3 возвращает с дробной частью)
	// - деление с округлением вниз
	%  - остаток от деления

	Чтобы выполнить усечение, можно использовать функцию math.trunc

		math.trunc(5 / -2)



	<
	>
	>=
	<=
	==
	!=
	!

	Идентичное сравнение

	X < Y < Z или X < Y and Y < Z




Строки

	Строки являются неизменяемыми последовательностями.

	Строки можно представить как :

	S = 'string'
	S = "string"
	S = '''
		String 
		'''
	S = r'string' - сырая строка
	S = 'A\nB\tC'
	ord('\n') - ASCII байт со значением 10


	Они поддерживают все операции с последовательностями. Например взятие по индексу

	S = 'Spam'
	len(S)  - длина 
	S[0]	- первый элемент
	S[0:3]  - слайс с первого по третий (0,1,2)
	S + 'xyz' - конкатенация
	S * 4	  - повторить 4 раза

	строковые методы

	S.find('pa') - ищет первое вхождение 'pa'
	S.replace('pa', 'ZYZ') - заменяет 'pa' на 'ZYZ'
	S.split(',') - разбивает строку по разделителю и создает массив
	S.upper() - в верхний регистр
	S.isalpha() - проверка содержимого 
	S.rstrip() - Удаляет завершающие пробельные символы
	'%s, eggs, and %s' % ('spam','SPAM!') - форматирование 'spam, eggs, and SPAM!'
	'{0}, eggs, and {1}'.format('spam','SPAM!') - то же


Слайсинг

	[1:3]	- с первого элемента по второй
	[1:]	- все кроме первого
	[:3]	- с первого до второго
	[:-1]	- все, кроме последнего
	[:]		- все



Списки

	Упорядоченные по местоположению изменяемые коллекции объектов произвольных типов

	L = [1,2,3,4,5,6]
	len(L) - длина 6
	L[0]   - первый элемент 1
	L[:-1] - срез 1,2,3,4,5
	L + [7,8,9]  - 1,2,3,4,5,6,7,8,9

	методы специфичные для списков

	L.append('10') - добавление в конец списка
	L.pop(2) - удаляется элемент с индексом 2 (эквивалент del L[2])
	L.sort()
	L.reverse()

	Если запрашиваемый индекс больше размера массива,то выдается ошибка

	Вложенные списки:

		M = [[1,2,3],
			 [4,5,6],
			 [7,8,9]]

		Получить значение можно как M [1][2]

	Генераторы списков

		Позволяют создавать новые списки, выполняя выражение для каждого
		элемента в последовательности

		col2 = [row[1] for row in M]

		[row[1] +1 for row in M if row[1] % 2 ==0]

		diag = [M[i][i] for i in [0,1,2,3,4,5]]

		doubles = [c * 2 for c in 'spam'] -> ['ss','pp','aa','mm']

	В 3-й версии генераторы списков могут генерировать результаты по требованию

		G = (sum(row) for row in M)
		next(G) -> 6
		next(G) - > 15

	В 3-й можно так же создавать множества и словари

		{sum(row) for row in M} -> {24,6,15}
		{i : sum(M[i]) for i in range(3)} -> {0:6,1:15,2:24}


		[ord(x) for x in 'spaam'] -> [115,112,97,97,109]
		{ord(x) for x in 'spaam'} -> {115,112,97,97,109}
		{x: ord(x) for x in 'spaam'} -> {'a': 97, 'p': 112, 's':115,'m':109}


Словари

	Они не столько последовательности, сколько отображения ( коллекция, в которой
	доступ предоставляется по ключам)

	D = {'food': 'Spam', 'quantity' : 4 , 'color' : 'pink'}
	C = {}

	D['food'] -> 'Spam'
	D['quantity'] +=1 -> {'quantity' : 5}

	пример использования

		rec = { 'name' : {'first':'Ivan','last':'Vasiliev'},
				'job' : ['dev':'mgr'],
				'age' : 40,5}

		rec['name'] -> {'first':'Ivan','last':'Vasiliev'}
		rec['name']['last'] -> 'Vasiliev'
		rec['job'].append('janitor') -> {.., 'job':['dev','mgr','janitor']}

	Сортировка по ключам ( for )

		Так как словарь не отсортирован, то перебрать его значения можно
		только по списку ключей :

		keys = list(D.keys())
		keys.sort()

		for key in keys:
			print(key, '=>', D[key])

		или

		for key in sorted(D):
			print(key, '=>', D[key])


Кортеж

	Это неизменяемый список

	T = (1,2,3,4,5,6,7,8)
	len(T)     -> 4
	T + (9,10)  -> 1,2,3,4,5,6,7,8,9,10

	T.index(4)  -> поиск позиции по значению
	T.count(4)  -> количество вхождений


Множество

	Это неупорядоченная колекция уникалных и неизменяемых объектов

	X = set('spam') -> ('s','p','a','m')
	Y = {'h','a','m'}

	X & Y -> пересечение {'a','m'}
	X | Y -> объединение {'a','s','p','h','m'}
	X - Y -> разность {'p','s'}



Файлы

	Чтобы создать файл, необходимо открыть его в режиме записи

	f = open('data.txt', 'w')
	f.write('world\n')  -> вернет кол-во байт (6)
	f.close()

	Чтобы открыть файл в режиме записи, нужно вторым параметром 
	указать r

	f = open('data.txt','r')
	text = f.read()		-> читает весь файл






Цикл for
	
	позволяет итерироваться по последовательностям

	for c in 'spammm':
		print(c)		-> s p a m m







